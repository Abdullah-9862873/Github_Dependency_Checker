ğŸ¯ Phase 1: Project Foundation (Days 1-2)
Goal: Set up the basic project structure and configuration
Step 1.1: Create Project Folder Structure
openclaw-guardian/
â”œâ”€â”€ skills/                    # Each skill is a separate Python module
â”‚   â”œâ”€â”€ __init__.py           # Makes skills a Python package
â”‚   â”œâ”€â”€ repo_monitor.py       # Handles Git clone/pull
â”‚   â”œâ”€â”€ dependency_checker.py # Runs npm outdated
â”‚   â”œâ”€â”€ upgrade_executor.py   # Runs npm update/install
â”‚   â”œâ”€â”€ pr_creator.py         # Creates GitHub PR
â”‚   â”œâ”€â”€ moltbook_poster.py    # Posts to Moltbook
â”‚   â””â”€â”€ memory_manager.py     # Handles persistent memory
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config_loader.py      # Loads configuration
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ logger.py             # Logging setup
â”‚   â””â”€â”€ validators.py         # Input validation
â”œâ”€â”€ memory.json               # Persistent memory file
â”œâ”€â”€ config.yaml               # Configuration file
â”œâ”€â”€ main.py                   # Main entry point
â”œâ”€â”€ requirements.txt          # Python dependencies
â””â”€â”€ README.md                 # Documentation
Step 1.2: Create requirements.txt
pyyaml>=6.0
requests>=2.28.0
GitPython>=3.1.0
Step 1.3: Create config.yaml
github:
  token: "${GITHUB_TOKEN}"       # GitHub Personal Access Token
  repo_url: ""                    # Repository to monitor
moltbook:
  api_key: "${MOLTBOOK_API_KEY}"
  api_url: "https://moltbook-api.example.com"  # Update with real URL
agent:
  check_interval: 3600            # Check every hour (in seconds)
  branch_prefix: "auto/dependency-update"
  
paths:
  working_directory: "./repos"    # Where to clone repos
  memory_file: "./memory.json"
Step 1.4: Create .env.example
GITHUB_TOKEN=ghp_your_token_here
REPO_URL=https://github.com/username/repo-name
MOLTBOOK_API_KEY=your_moltbook_key
CHECK_INTERVAL=3600
---
ğŸ§  Phase 2: Core Infrastructure (Days 2-3)
Goal: Build the foundation components that other skills depend on
Step 2.1: Config Loader (skills/config_loader.py)
- Load config.yaml
- Read environment variables
- Provide configuration to all other skills
- Validate required fields exist
Step 2.2: Logger Setup (utils/logger.py)
- Create formatted logger
- Log to console and file
- Different log levels (DEBUG, INFO, WARNING, ERROR)
Step 2.3: Memory Manager (skills/memory_manager.py)
What it does: Stores what the agent has done so it doesn't repeat work
Functions needed:
- load_memory() - Read memory.json
- save_memory() - Write to memory.json
- get_last_check_time() - When did we last check?
- record_upgrade(branch_name, packages) - Save upgrade info
- has_been_upgraded(package_name) - Check if package was recently upgraded
- clear_old_entries() - Keep memory clean (optional)
Memory JSON structure:
{
  repo_url: https://github.com/user/project,
  last_checked: 2024-01-15T10:30:00Z,
  last_updated: [
    {
      branch: auto/dependency-update-1705312200,
      packages: [lodash, axios],
      timestamp: 2024-01-15T10:35:00Z,
      pr_url: https://github.com/user/project/pull/5
    }
  ],
  total_runs: 15,
  successful_upgrades: 8
}
---
ğŸ–¥ï¸ Phase 3: Repository Monitor Skill (Days 3-4)
Goal: Be able to clone and update a GitHub repository
Step 3.1: GitHub Authentication Setup
- Use GitHub Personal Access Token
- Configure git credentials
- Test authentication
Step 3.2: Clone Repository (if not exists)
- Check if repo folder exists
- If not: git clone https://token@github.com/user/repo.git
- Store cloned repo path
Step 3.3: Pull Latest Changes
- Navigate to repo directory
- Run git fetch origin
- Run git pull origin main (or master)
- Handle branch name detection
Step 3.4: Ensure Clean Working Directory
- Check for uncommitted changes
- Stash changes if any
- Or warn if there are local modifications
Functions to create:
- clone_repo(repo_url, token) - Clone if not exists
- pull_latest(repo_path) - Get latest code
- is_clean_working_directory(repo_path) - Check for changes
---
ğŸ“¦ Phase 4: Dependency Checker Skill (Days 4-5)
Goal: Detect which packages are outdated
Step 4.1: Run npm outdated
- Execute: npm outdated --json
- Parse JSON output
- Handle empty output (no outdated packages)
Step 4.2: Parse Outdated Package List
Example npm outdated output:
{
  lodash: {
    current: 4.17.15,
    wanted: 4.17.21,
    latest: 4.17.21,
    dependent: myproject,
    location: /path/to/node_modules/lodash
  },
  axios: {
    current: 0.27.0,
    wanted: 0.27.2,
    latest: 1.6.0,
    dependent: myproject,
    location: /path/to/node_modules/axios
  }
}
Step 4.3: Filter Packages to Upgrade
- Get list of all outdated packages
- Check memory to avoid re-upgrading recently upgraded ones
- Return list of packages that need updating
Functions to create:
- check_outdated(repo_path) - Run npm outdated, return list
- parse_outdated_packages(json_output) - Convert to usable format
- filter_packages_to_upgrade(outdated_list, memory) - Remove recently upgraded
---
ğŸ”„ Phase 5: Upgrade Executor Skill (Days 5-6)
Goal: Actually upgrade the dependencies
Step 5.1: Run npm update
- Execute: npm update in repo directory
- Capture output and errors
- Track which packages were updated
Step 5.2: Run npm install
- Execute: npm install
- This ensures package-lock.json is updated
- Validates that dependencies work together
Step 5.3: Handle Failures
If npm install fails:
- Log the error
- Post failure update to Moltbook
- Store error in memory
- Abort the branch creation
- Return failure status
If npm install succeeds:
- Continue to PR creation
- Log success
Step 5.4: Capture Updated Package List
- Compare old package.json with new one
- Extract list of actually upgraded packages
Functions to create:
- upgrade_dependencies(repo_path) - Run npm update
- validate_installation(repo_path) - Run npm install
- get_updated_packages(old_package_json, new_package_json) - Compare versions
---
ğŸ“ Phase 6: Pull Request Skill (Days 6-7)
Goal: Create a Git branch and submit a pull request
Step 6.1: Create New Branch
- Generate branch name: auto/dependency-update-{timestamp}
- Execute: git checkout -b branch_name
- Verify branch created
Step 6.2: Stage Changed Files
- Add package.json
- Add package-lock.json
- Execute: git add package.json package-lock.json
Step 6.3: Create Commit
- Generate commit message
- Example: "Auto: Upgrade outdated dependencies"
- Execute: git commit -m "message"
Step 6.4: Push Branch to GitHub
- Execute: git push origin branch_name
- Use token for authentication
Step 6.5: Create Pull Request (via GitHub API)
- Use GitHub REST API: POST /repos/{owner}/{repo}/pulls
- PR Title: "Auto: Upgrade outdated dependencies"
- PR Body includes:
  - List of upgraded packages
  - Timestamp
  - "Created autonomously by OpenClaw Guardian"
- Capture PR URL
Functions to create:
- create_branch(repo_path, branch_name) - Create git branch
- commit_changes(repo_path, packages) - Commit updated files
- push_branch(repo_path, branch_name) - Push to GitHub
- create_pull_request(github_token, repo_url, branch_name, packages) - Create PR via API
---
ğŸ“£ Phase 7: Moltbook Posting Skill (Days 7-8)
Goal: Post updates to Moltbook to demonstrate autonomy
Step 7.1: Define Post Types
Events to post:
1. Agent Started - "OpenClaw Guardian started monitoring {repo}"
2. Outdated Detected - "Found {count} outdated packages: {list}"
3. Upgrade Started - "Upgrading packages: {list}"
4. Upgrade Success - "Successfully upgraded {list}. PR created: {url}"
5. Upgrade Failed - "Failed to upgrade. Error: {message}"
6. No Updates Needed - "All dependencies are up to date"
Step 7.2: Implement Moltbook API Client
- Make HTTP POST requests to Moltbook API
- Include authentication header
- Format message as JSON
- Handle API errors gracefully
Step 7.3: Add Error Handling
- Log if Moltbook post fails
- Don't let Moltbook failure stop the main workflow
Functions to create:
- post_to_moltbook(message, event_type) - Send update to Moltbook
- format_progress_message(event_type, data) - Create message content
---
ğŸ”„ Phase 8: Main Loop & Orchestration (Days 8-9)
Goal: Tie everything together into an autonomous loop
Step 8.1: Create Main Loop
def main():
    config = load_config()
    memory = load_memory()
    
    while True:
        try:
            # Step 1: Post starting message
            post_moltbook("Agent started", "started")
            
            # Step 2: Ensure repo is up to date
            clone_or_pull_repo(config)
            
            # Step 3: Check for outdated packages
            outdated = check_outdated(config)
            
            if outdated:
                # Step 4: Upgrade dependencies
                success = upgrade_dependencies(config)
                
                if success:
                    # Step 5: Create PR
                    pr_url = create_pull_request(config, outdated)
                    
                    # Step 6: Update memory
                    record_upgrade(pr_url)
                    
                    # Step 7: Post success to Moltbook
                    post_moltbook(f"PR created: {pr_url}", "success")
                else:
                    post_moltbook("Upgrade failed", "failure")
            else:
                post_moltbook("No outdated packages", "check")
                
            # Step 8: Wait for next interval
            sleep(config.check_interval)
            
        except Exception as e:
            log_error(e)
            post_moltbook(f"Error: {str(e)}", "error")
            sleep(60)  # Short sleep on error
Step 8.2: Add Signal Handling
- Handle Ctrl+C gracefully
- Save memory before exit
- Log shutdown
Step 8.3: Add Command-Line Arguments
- --once - Run one cycle only (for testing)
- --config - Custom config file path
- --verbose - Enable debug logging
---
âœ… Phase 9: Testing & Demo Preparation (Days 9-10)
Goal: Ensure everything works for the hackathon demo
Step 9.1: Unit Tests for Each Skill
- Test config loader
- Test memory manager
- Test dependency checker parsing
- Mock external API calls
Step 9.2: Integration Test
- Use a test repository with intentionally outdated packages
- Run full cycle
- Verify PR is created
Step 9.3: Demo Script Preparation
- Create README with:
  - Setup instructions
  - How to get GitHub token
  - How to configure repo
  - How to run
- Create demo video script
Step 9.4: Error Handling Improvements
- Add retries for network failures
- Add timeout handling
- Improve error messages
---
ğŸ“Š Implementation Checklist
| Phase | Feature | Estimated Time |
|-------|---------|----------------|
| 1 | Project Foundation | 2 days |
| 2 | Core Infrastructure | 1 day |
| 3 | Repository Monitor | 1 day |
| 4 | Dependency Checker | 1 day |
| 5 | Upgrade Executor | 1 day |
| 6 | Pull Request Skill | 1 day |
| 7 | Moltbook Posting | 1 day |
| 8 | Main Loop | 1 day |
| 9 | Testing & Demo | 2 days |
| Total | | 11 days |
---
ğŸ”§ Technical Details (For Reference)
GitHub API Endpoints Used
- Get repo info: GET /repos/{owner}/{repo}
- Create ref: POST /repos/{owner}/{repo}/git/refs
- Create commit: POST /repos/{owner}/{repo}/git/commits
- Create PR: POST /repos/{owner}/{repo}/pulls
File Locations After Implementation
openclaw-guardian/
â”œâ”€â”€ skills/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ repo_monitor.py       # 120 lines
â”‚   â”œâ”€â”€ dependency_checker.py # 80 lines
â”‚   â”œâ”€â”€ upgrade_executor.py   # 100 lines
â”‚   â”œâ”€â”€ pr_creator.py         # 150 lines
â”‚   â”œâ”€â”€ moltbook_poster.py    # 60 lines
â”‚   â””â”€â”€ memory_manager.py     # 80 lines
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config_loader.py      # 50 lines
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ logger.py             # 40 lines
â”‚   â””â”€â”€ validators.py         # 30 lines
â”œâ”€â”€ memory.json               # Generated
â”œâ”€â”€ config.yaml               # User config
â”œâ”€â”€ main.py                   # 100 lines
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
---
â“ Questions Before Implementation
1. Molbook API: Please provide the API documentation or endpoint URLs so I can implement the poster correctly.
2. GitHub Repository: What repository URL should I use for testing?
3. Check Interval: Is 1 hour (3600 seconds) good, or should it be different for demos?
4. Branch Name Format: Is auto/dependency-update-{timestamp} acceptable, or do you prefer a different format?
5. Package Filtering: Should the agent upgrade ALL outdated packages, or should it skip major version jumps (e.g., skip axios 0.27 â†’ 1.6.0)?